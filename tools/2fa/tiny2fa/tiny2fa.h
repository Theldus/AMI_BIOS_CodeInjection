/*
 * MIT License
 *
 * Copyright (c) 2018-23 Davidson Francis <davidsondfgl@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef TINY2FA_H
#define TINY2FA_H

#include "cmos.h"
#include "util.h"
#include "sha1.h"
#include "hmac.h"
#include "base32.h"

#include "types.h"

/* Secret key size, in bytes. */
#define T2_SECRET_KEY_SIZE 20

/* Time padded size, in bytes. */
#define T2_TIME_PADDED 8

/* Interval for generating keys, in seconds. */
#define T2_KEY_INTERVAL 30

/* Amount of digits for the final key. */
#define T2_TOTP_DIGITS 1000000

/* Key length while encoded in base32. */
#define T2_KEY_ENCODED_LENGTH 32

/* Default window size. */
#define T2_DEFAULT_WINDOW_SIZE 3

/**
 * Gets the current key based in the base32 secret
 * key passed by parameter and the reference time.
 *
 * @param b32_secret_key Your secret-key, generated by
 * the method @m t2_generate_secret_key.
 *
 * @param tm target time in Unix Time Stamp, if 0, uses
 * the current time.
 *
 * @return Returns the key equivalent for the current time
 * and secret key.
 *
 * @see t2_generate_secret_key
 */
static int t2_get_key(const uint8_t *b32_secret_key, uint32_t tm)
{
	uint8_t  sk[T2_SECRET_KEY_SIZE];       /* Original secret key.      */
	uint8_t  hmac[SHA1_DIGEST_LENGTH];     /* HMAC.                     */
	uint8_t  time_padded[T2_TIME_PADDED];  /* Time padded into 8 bytes. */
	uint64_t ctime;                        /* Reference time.           */
	int offset;                            /* Result offset.            */
	int result;                            /* Result.                   */

	/* Time. */
	ctime = (tm != 0) ?
		tm / T2_KEY_INTERVAL :
		(uint32_t)cmos_read_unix_time() / T2_KEY_INTERVAL;

	/* Decode secret-key. */
	base32_decode(b32_secret_key, sk, T2_SECRET_KEY_SIZE);

	/* Pad time into a byte array. */
	for (int i = T2_TIME_PADDED - 1; i >= 0; i--)
	{
		time_padded[i] = ctime;
		ctime >>= 8;
	}

	/* Calculates hmac. */
	hmac_sha1(sk, T2_SECRET_KEY_SIZE, time_padded, T2_TIME_PADDED, hmac,
		SHA1_DIGEST_LENGTH);

	/* Get offset and result. */
	offset = hmac[SHA1_DIGEST_LENGTH - 1] & 0xF;
	result = (
			((hmac[offset + 0] & 0x7F) << 24) |
			((hmac[offset + 1] & 0xFF) << 16) |
			((hmac[offset + 2] & 0xFF) <<  8) |
			((hmac[offset + 3] & 0xFF))  );

	result &= 0x7FFFFFFF;
	result %= T2_TOTP_DIGITS;

	/* Clear sk, hmac and time_padded. */
	memset(sk, 0, T2_SECRET_KEY_SIZE);
	memset(hmac, 0, SHA1_DIGEST_LENGTH);
	memset(time_padded, 0, T2_TIME_PADDED);

	return (result);
}

/**
 * Verifies a given base32 secret key through the key provided
 * and a certain window.
 *
 * @param b32_secret_key Your secret-key, generated by
 * the method @m generate_secret_key.
 *
 * @param key User provided key, this is the key to be checked.
 *
 * @param window Validation window. Passing 0 the default value
 * (default = 3) will be used. With default value, will be
 * generated 3 keys: before current time, current time and after.
 * The key will be compared with these n-window keys and if one of
 * them is equal to the key provided the function returns a non
 * negative number and 0 otherwise.
 *
 * @return Returns a non-negative number if the key is valid and
 * 0 otherwise.
 */
static int t2_verify_key(const uint8_t *b32_secret_key, int key, int window)
{
	uint32_t ctime;      /* Current time.            */
	int      offset;     /* Start window multiplier. */
	ctime = cmos_read_unix_time();

	/* Check window size. */
	if (!window)
		window = T2_DEFAULT_WINDOW_SIZE;

	/* Window must be an odd number. */
	if ( !(window & 1) )
		return (-1);

	/* Check through all the keys given the window range. */
	offset = -((window-1)/2);
	for (int i = 0; i < window; i++)
	{
		uint32_t iter_time = ctime + (offset * T2_KEY_INTERVAL);
		if (t2_get_key(b32_secret_key, iter_time) == key)
			return (1);

		offset++;
	}

	return (0);
}

#endif /* TINY2FA_H */
